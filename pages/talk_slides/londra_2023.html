<!--
.. title: A physicist's perspective on publishing open source software
.. slug: londra_2023
.. date: 2023-09-14 10:01:00 UTC+02:00
.. tags: 
.. category: talks
.. link: 
.. description: 
.. type: text
.. template: reveal.tmpl
.. has_math: true
-->


<!-- .slide: data-background-image="/images/talks/londra_2023/background.png" data-background-size="90%" data-background-opacity="0.15" -->

# A physicist's perspective on publishing open source software<!-- .element: style="font-size: 190%" -->

<div style="height:80px"></div>

## Lorenzo Rovigatti

### Physics Department, Sapienza University of Rome
### Simulation and Interfacial Free Energy Techniques Group, Brunel University London, September 5th, 2023

---

# My background

* I am a physicist, I do simulations of coarse-grained soft-matter systems

<div style="display:flex; border:2px solid black;width:650px;margin:auto;font-size:90%; padding:10px; margin-top: 10px">
    <div style="flex:50%">
        <div>
            Self-assembly<br/>
            <img src="/images/talks/londra_2023/dhs.png" width="55%">
        </div>
        
        <div>
            Colloidal crystals<br/>
            <img src="/images/talks/londra_2023/crystallisation.png" width="50%">
        </div>
    </div>
    
    <div style="flex:50%">
        <div>
            All-DNA materials<br/>
            <img src="/images/talks/londra_2023/DNA_gel.png" width="55%">
        </div>
        
        <div>
            Polymers<br/>
            <img src="/images/talks/londra_2023/microgels.png" width="80%">
        </div>
    </div>
</div>

---

# Some disclaimers

<div class="fragment warning">
I have no formal training in Computer Science or Software Engineering
</div>

<div class="fragment warning">
I'll talk about things that can be done in very different ways, I'll be reporting no more than my own experience 
</div>

<div class="fragment focus">
A lot of open-source software has better documentation, examples and tests than mine, but I want to show what a non expert can do!
</div>

<div class="fragment focus">
I deeply believe that releasing open-source software is a win-win, as it benefits both the maintainer as well as the community
</div>

<div class="fragment focus">
I maintain several repositories online, some of them are used by others than myself (or close collaborators)
</div>

---

# Some useful* software I wrote (or co-wrote)

<small>* useful in the sense that it has been used or is being used by others</small>

* [oxDNA](https://github.com/lorenzo-rovigatti/oxDNA): simulations of DNA, RNA and other coarse-grained systems. It has been used in hundreds of publications ($\approx 1000$ downloads per year).
* [tacoxDNA](https://github.com/lorenzo-rovigatti/tacoxDNA): A collection of tools for DNA modelling ($\approx 200$ downloads per year).
* [PatchyParticles](https://github.com/lorenzo-rovigatti/PatchyParticles.git): A tutorial code to perform efficient Monte Carlo simulations of patchy particles ($\approx 100$ downloads per year).
* [cogli2](https://sourceforge.net/projects/cogli1/): a visualisation tool for (my) coarse-grained systems: a poor man's VMD ($\approx 100$ downloads per year).
* [pyrla.py](https://github.com/lorenzo-rovigatti/pyrla): an agnostic tool to launch multiple jobs (usually simulations) with different parameters ($\lt 10$ downloads per year).
* [baggianalysis](https://github.com/lorenzo-rovigatti/baggianalysis): a C++/Python library to facilitate the analysis of molecular simulations  (??? downloads per year).

<div class="fragment focus">
All these tools are accompanied by READMEs, examples and, if they are sufficiently large to benefit from them, full API documentation and tests
</div>

---

# Disadvantages of open sourcing your software

<div class="fragment">
<img src="/images/talks/londra_2023/pulp-fiction-john-travolta.gif" width=400>
</div>

<div class="fragment focus">
Your mileage may vary, but 

* Nobody is going to use your code better than you do
* Some people can be a nuisance (when signalling issues or asking for features), but you quickly learn how to handle that (and you get funny stuff as well!)
</div>

<div class="fragment" style="position:fixed; z-index:2; top:0%; width:100%">
<img src="/images/talks/londra_2023/funny.png" style="height:680px">
</div>

---

# Advantages of open sourcing your software

## Idealistic reasons<!-- .element: class="block-title"-->

* Available code can greatly help other researches
* Sharing is (should be?) at the core of scientific progress
* People can more easily reproduce ($=$ check) your results

<div class="fragment">

## Pragmatic reasons<!-- .element: class="block-title"-->

* If used by others, your code will be tested in ways you can't imagine
* If you use best practices, you'll be pushed to write better code, tests and documentation
    * Makes it easier to convince people that your results are reproducible
    * Makes it easier to collaborate with other people
* If people use your code you get recognition &amp; citations
    
</div>

---

# Releasing your software: a checklist

## A minimalistic checklist:<!-- .element: class="block-title"-->

- [ ] A publicly-available repository
- [ ] A license (*e.g.* GPL3, MIT, BSD)

<div class="fragment">

## What you also need in pratice:<!-- .element: class="block-title"-->

- [ ] Documentation
- [ ] Examples
- [ ] Tests
</div>

Fulfilling all these requirements will greatly help yourself even if you are the only one using your software<!-- .element: class="fragment focus" -->

---

# The license

Here I quote [choosealicense.com](https://choosealicense.com) (use it to delve into open source licensing!)

<ul>
    <li class="fragment"><b>Always pick a license</b>: <q>Unless you include a license that specifies otherwise, nobody else can copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation</q></li>
    <li class="fragment"><b>MIT license</b>: <q>short and to the point, it lets people do almost anything they want with your project, like making and distributing closed source versions</q></li>
    <li class="fragment"><b>GPL license</b>: <q>lets people do almost anything they want with your project, except distributing closed source versions</q></li>
    <li class="fragment">There are many other licenses: take a tour online if you feel adventurous</li>
</ul>

For codes like the ones we write any open source license will do. I tend to use the GPL because I like its "virality"<!-- .element: class="fragment focus" -->

</div>

---

# Documentation

<blockquote>
Documentation is a love letter that you write to your future self.
</blockquote>

<div class="fragment">

* Writing documentation is tedious
* **Anything** that forces you to write documentation should be welcome
* You write documentation
    1. For yourself
    2. For your students/collaborators
    3. For others

</div>

<div class="focus fragment">
In many cases a well-done README file is sufficient
</div>

<div class="warning fragment">
Don't forget to update the documentation as the code changes
</div>

---

# A [README file](https://github.com/lorenzo-rovigatti/pyrla/blob/master/README.md) I read very often

<div style="overflow-y: scroll; height:500px; background-color: white; padding:15px; font-size: 70%">

# pyrla

pyrla makes it easy to launch parallel processes that execute different commands. Its most common use case is having to run the same command in different directories ordered in a specific hierarchy (e.g. `Temperature_T/Pressure_P`, for several values of `P` and `T`). Perhaps the command should be invoked with folder-specific parameters. pyrla makes it easier to automatise this type of repetitive operations without having to resort to bash scripts or similar means. 
With pyrla, you can choose the number of contemporary jobs and their working path, which can be automatically generated. 
If the command you want to execute takes an input file as an argument (or if you want to have a bespoke file in each job's current directory), such an input file can be written on the fly or generated from an existent input file.
    
## Usage

pyrla expects a single input file (see [Input file syntax](#input-file-syntax)). It also supports the following options:

```text
-d, --debug 
    enable debug (verbose) mode. Useful for developers
--ends-after n
    run the first n jobs only
-h, --help
    show a usage message
--max-states n
    set the maximum number of states (jobs) that can be generated. Defaults to 100000
-r, --dry-run
    show a complete summary of the jobs that will run. Useful for testing input files
-S, --summarise
    show a synthetic summary of the run
-s, --safe
    enable safe mode. No file or directory will be overwritten
--start-from n
    start jobs having an id >= n
-v, --version
    show the version of the program
-w, --wait n
    wait n seconds before starting the jobs (after the parsing of the input file)
```

## Examples

The `pyrla/examples/` folder contains commented pyrla input files that can be used as starting points to build your own.

## Input file syntax

* Empty lines or lines starting with a hash sign (\#) will not be considered. A well-formed line should look like 'key = value'. Spaces before and after key and value are stripped off.
* Any text coming after a hash sign (\#) will be discarded.
* About the 'value' syntax:
    * in general if your value contains spaces then it will be considered as a 'special' value (a mathematical expression or a list of values, for examples). If you want to avoid this you have to put double quotes (") around the whole value.
    * you can refer to other values by using the syntax $(key). The value of 'key' will be expanded at runtime. An example would be `T_$(T)`.
    * you can use mathematical expressions by enclosing them with ${ and }. An example would be `${2 + 3}`. You can also use complex functions (as long as they are defined in python's math module). An example would be `${log($(T)) + 0.2}`.
    * you can load a list of values from a file by using the syntax `key = LF filename`. Each row will be treated as an item of the list.
    * you can use complex sequences in a way similar to bash's seq or python's range but in a more flexible way. The actual syntax is: `F start T target V inc`. Of course start is the starting value while target is the final value (excluded from the sequence, like in C-style for loops) and inc is the action to be performed on start to go towards target. A simple example would be `T = F 0.1 T 0.4 V +0.1` which is equivalent `T = 0.1 0.2 0.3`. You can also have more complex sequences like `T = F 0.1 T 100 V *10`, which is equivalent to `T = 0.1 1 10`.
    * you can evaluate a bash command and assign its value to a pyrla variable by enclosing the command between $b{ and }. For example, `a = $b{echo "prova"}` would assign the value 'prova' to the key 'a' 
* There are some special keys used as 'keywords'. These are:
    * `DirectoryStructure`: structure of the directory where the `Execute` command should be executed. It can depend on other variables (for example one can have `DirectoryStructure = T_$(T)_Act_$(Activity)`). 
    * `CopyFrom`: path (absolute or relative to the pyrla script launching directory) to the base configuration file to be changed. This key may not contain expressions or list of values.
    * `CopyTo`: name of the base configuration whose keys will be taken from InputFrom (and modified using the InputFromOverwrite). This file will be copied to the directory given by DirectoryStructure. If this key is missing then the file will have the same name as the CopyFrom
    * `CopyToWrite`: name of the keys that should be written in the CopyTo file (if a CopyFrom is specified and it contains any of these keys they will be overwritten).
    * `CopyObjects`: one or more paths (absolute or relative to the pyrla script launching directory) to be copied under each job's working directory.
    * `Execute`: the command to execute.
    * `PreExecute`: a command to be executed before `Execute`. If the command exits with a non-zero exit code no other command will be run.
    * `PostExecute`: a command that will be executed after `Execute` if and only if `Execute` exits with a zero exit code.
    * `Relaunch`: if True relaunch jobs that return non-zero exit codes. Note that only the `Execute` command gets re-launched.
    * `ContemporaryJobs`: maximum number of jobs to be executed together. This key may not contain expressions or list of values. If 0 then no max will be set. Defaults to 0.
    * `RunConditions`: a list of comma-separated conditions that each job should be met in order to be run. Each condition should be a Python expression which can be based on the user-defined key values. However, note that by default all the keys are initialised as strings, so that numeric keys must be explicitly cast to numeric types if numeric comparisons are to be carried out. An example is `RunConditions = float(T) < 2, log(float(Activity)) > 1`.
    * `WaitingTime`: waiting time (in seconds) between job launches. Defaults to 2 seconds.
    * `Subdirectories`: one or more directories (separated by spaces) to be created from each job under the DirectoryStructure folder. An example: `Subdirectories = confs sus/special` will create two folders under the job's working directory (determined by `DirectoryStructure``): confs and sus. In addition, a directory called "special" under the sus folder will be created.
    * `Times`: how many times the jobs must be executed.
    * `InputSeparator`: a character or a string which is used to separate keys from values in the input file (the `CopyFrom` one). Default is the equal sign '='.
    * `Exclusive`: if True, no more than one job per directory can be executed.
        
* The following built-in keys can be used in user-defined keys:
    * `JOB_ID`: expands to the current job's id, which is 0 for the first job, 1 for the second, etc.
    * `BASE_DIR`: the directory pyrla was launched from.
    
* It is possible to have keys take specific values when one or more conditions are met. For example, `Delta = 0.2 @@ T = 0.1, Activity = 1e-5` will assign to Delta the value 0.2 for all those processes that have the two keys T and Activity take the values 0.1 and 1e-5, respectively. As of now, the only conditions available are comma-separated lists of specific values of keys.
        
## Syntax of the CopyFrom file

pyrla supports different types of `CopyFrom` file. The type of file can be set by using the `InputType` key.

### Default syntax

By default pyrla expects a file containing a list of `key = value` lines. In this case

* A key listed under the `CopyToWrite` keyword will overwrite a value in the `CopyFrom` file if the `CopyFrom` file contains that same key in one of its `key = value` line. Here "same" is meant in a case sensitive way. The default separator is `=`. You can use the `InputSeparator` key in the input file to change the separator. 
* For each `CopyToWrite` key that is not in the `CopyFrom`, a `key = value` line will be appended at the end of the file.

### LAMMPS input file

If `InputType = LAMMPS` then pyrla will expect a LAMMPS input file. In this case

* A key listed under the `CopyToWrite` keyword will overwrite a value in the `CopyFrom` file if the `CopyFrom` file contains a `variable key ...`. In this case the line will be replaced by `variable key equal value`.
* Any `CopyToWrite` key that is not in the `CopyFrom` file will not be used (and a warning will be issued).

### Jinja2 templates

If `InputType = Jinja2` then pyrla will expect a [Jinja2](https://palletsprojects.com/p/jinja/) template file. In this case the values associated to the keys specified in `CopyToWrite` will be passed to the Jinja template. This feature requires the `jinja2` python package to be installed.

## A security warning

Note that the evaluation of math keys and run conditions require the use of Python's `eval` function, which is [known to be insecure](https://softwareengineering.stackexchange.com/a/311510). Be careful.
    
## Acknowledgements

* I took the idea of a python-based launcher from John Russo and his gotmilkneedpy

</div>

---

# Detailed docs

* For larger codes it is better to provide a more thorough (or perhaps just easier to browse) documentation.
* There are many tools that can help you generating and publishing well-formatted documentation
* You can copy from other open-source repositories to learn how to do it
* Once you have a structure that works for you, you can reuse it for all your software

<div class="fragment focus">
For instance, I use <a href="https://www.sphinx-doc.org/en/master/">sphinx</a> and a <a href="https://github.com/demonico85/cleaving/blob/master/.github/workflows/build-docs.yml">github CI workflow</a> to generate &amp; publish my documentation online
</div>

<div class="fragment" style="position:absolute; z-index:2; top:0%; width:100%">
<img src="/images/talks/londra_2023/cleaving_docs.png" style="width:100%">
</div>

---

# Examples

* There is hardly anything better than a well-crafted example to learn how to use a specific software
* **Always** add one or more examples
    * to the README if the software and its usage are straightforward
    * in dedicated folders otherwise
* Describe what each example does and guide the user ($=$ yourself or a student of yours most of the time) through each step
* I think (hope?) that [this](https://demonico85.github.io/cleaving/example_SV_wells.html) example from the CLEAVING package is a good example (!)
* The more complicated the software, the more examples you should provide
<img src="/images/talks/londra_2023/oxDNA_examples.png" class="fragment">

---

# Tests

<blockquote>
Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.
</blockquote>

<div class="fragment">

Tests are useful for several reasons

1. Users can check whether the software works on their machines
2. Developers can check that their changes did not break any (important) feature
3. Can be run automatically after each change/commit/release (*e.g.* GitHub CI)
4. As for the examples, more features $\to$ more tests

<div class="fragment" style="position:absolute; z-index:2; top:0%; width:100%">
<img src="/images/talks/londra_2023/oxDNA_tests.png" style="border: 2px solid black;width:500px;">
</div>

</div>

---

# Conclusions

* Publishing open-source software benefits **everyone**
* Publishing open-source software has a non-negligible upfront cost which (in general) you only pay once<!-- .element: class="fragment" -->
* Publishing open-source software will pay back dividends (if only when you will pat yourself in the back while reading the documentation you wrote yourself)<!-- .element: class="fragment" -->
* There are many tools &amp; techniques that can really help when writing docs &amp; tests<!-- .element: class="fragment" -->
* If you are interested I'm happy to share all the nuts &amp; bolts of what I do<!-- .element: class="fragment" -->

<div class="block-title fragment">
Thank you, and I hope I did not bore you too much!
</div>

---

# Bonus slide

<div class="focus">One massively annoying thing: when your software gets no acknowledgement</div>

<div class="fragment">
    <img src="/images/talks/londra_2023/oxDNA_cite_1.png" style="width:430px">
    <img src="/images/talks/londra_2023/oxDNA_cite_3.png" style="width:430px">
    <img src="/images/talks/londra_2023/oxDNA_cite_2.png" style="width:430px">
</div>
